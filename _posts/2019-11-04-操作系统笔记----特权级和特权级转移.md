---
layout:     post
title:      操作系统笔记
subtitle:   TSS
date:       2019-11-04
author:     Shawn
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - 操作系统




---

# 操作系统笔记：特权级和特权级转移（转载）

保护模式的保护，主要体现在特权级别上，这也是保护模式相对与实模式的巨大改进。

特权级按照权利大小从小到大分为0，1，2，3级，数字越小，权利越大。



![img](https:////upload-images.jianshu.io/upload_images/7304940-96bdef5ac9cb2c47.png?imageMogr2/auto-orient/strip|imageView2/2/w/235/format/webp)

操作系统位于最内环的 0 级特权，它要直接掌控硬件，掌控各种核心数据，所以它的权利最大。
 系统程序位于 1 ，2 级特权，运行在这2层的一般是虚拟机，驱动程序等系统服务。
 最外层的是是用户程序。

##### example



![img](https:////upload-images.jianshu.io/upload_images/7304940-c76325d33a36f882.png?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

在CPU中运行的指令，其指令总会属于某个代码段，这个代码段中的 DPL 字段就是 **当前特权级CPL**(Current Privilege Level)。



![img](https:////upload-images.jianshu.io/upload_images/7304940-cc4a72e12c73b1d9.png?imageMogr2/auto-orient/strip|imageView2/2/w/413/format/webp)

当处理器特权级的条件通过后，新代码段的 DPL 就变成了处理器的 CPL，也就是目标代码段描述符的 DPL 字段将保存在代码段寄存器 CS 中的 RPL 位。

##### 权限检查

- 受访者为数据段 (对于描述符中 type 字段中未有X可执行属性)
   只有访问者的权限 **大于等于该 DPL** 表示的权限才能够继续访问。比如，DPL为1，只有特权级为0，1的访问者才能访问。

- 受访者为代码段 (对于描述符中 type 字段中未有X可执行属性)
   只有访问者的权限 **等于该DPL** 表示的权限才能够继续访问，即只能平级访问。

  低特权级能做的事，高特权级也能做，正常情况下，CPU没有必要先自降等级去做。
   唯一例外的是，处理器从中断处理程序中返回用户态的时候，在运行用户程序的时候，发生了中断，CPU会暂停用户程序的执行，随后 CPU 就会自动由 3 特权级进入到 0 特权级，调用相应中断处理，待中断处理完成之后，CPU 会恢复用户程序的执行，也就是恢复到 3 特权级。

但现在由这样的问题，如果处理器仅能平移代码段的话，另外3个特权级的代码将没有机会运行，如何穿过特权屏障？即执行高特权级代码段上的指令，而又不提升特权级。一种方法就是利用一致性代码段。
 在段描述符中，如果该段为非系统段，可以用 type 字段中的 C 位来表示该段是否为一致性代码段。

##### 门

CPU 只有通过 "门结构" 才能实现由低特权级转移到高特权级，即从用户态进入到内核态。

门结构就是记录一段程序起始地址的描述符。



![img](https:////upload-images.jianshu.io/upload_images/7304940-191e68c505b10eee.png?imageMogr2/auto-orient/strip|imageView2/2/w/751/format/webp)

任务门以任务状态段 TSS 为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生后，对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用 call 或 jmp 指令后接任务门的选择子或任务TSS 的选择子。



![img](https:////upload-images.jianshu.io/upload_images/7304940-4fcc01b4fb14b9f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/751/format/webp)

以 int 指令主动发起中断的形式实现从低特权级向高特权级转移，Linux 系统调用便用此实现。



![img](https:////upload-images.jianshu.io/upload_images/7304940-cc096b4f034b6caa.png?imageMogr2/auto-orient/strip|imageView2/2/w/751/format/webp)

以 int3 指令主动发起中断的形式实现从低特权级向高特权级转移，编译器调试用。



![img](https:////upload-images.jianshu.io/upload_images/7304940-7527a24392a38e93.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)

call 和 jmp 指令后接调用门选择子作为参数，以调用函数实现从低特权向高特权级转移，可用来实现系统调用。但主流OS都是用中断门实现系统调用。

以上是4种门描述符，除了任务门外，其他三种门都是对应一段例程，即对应一段函数，而不是像段描述符对应的是一片内存区域。
 例程用**段描述符**给出基址，再加上门描述符中给出**偏移量**。这也是门描述符需要记录选择子和偏移量的原因。

任务门描述符可以放在GDT，LDT和IDT中，调用门可以位于GDT，LDT中，中断门和陷阱门只位于IDT中。

##### 调用门

-  

##### 调用门的过程保护

调用门涉及2个特权级，显示转移前的低特权级，这是程序调用"调用门" 时的 CPL，再就是转移后的目标特权级，这是由门描述符中选择子对应的目标代码段的 DPL 决定的。

假设用户进程要调用某个调用门，该门需要 2 个参数。调用前的当前特权级为 3，调用后的新特权级为 0，所以调用门转移前用的是 3 特权级栈，调用后用的是 0 特权级栈。也

- 现在为此调用门提供2个参数，这是在使用调用门前完成的，目前是在3特权级的栈

  

  ![img](https:////upload-images.jianshu.io/upload_images/7304940-72b0a66de9800c88.png?imageMogr2/auto-orient/strip|imageView2/2/w/354/format/webp)

  使用调用门前用户进程的栈.png

- 在这一步中，我们要确定新特权级使用的栈，新特权级也就是转移后目标代码段的 DPL，根据调用门中描述符中的选择子对应的目标代码段的DPL。这里为0，处理器会自动在 TSS 中找到合适的栈段选择子 SS 和 栈指针 ESP，它们作为转移后的新栈，记录为 SS_new 和 ESP_new。

- 检查新栈段选择子对应的描述符的 DPL 和 TYPE。

- 如果转移后的目标代码段 DPL 比 CPL 要高，说明栈段选择子 SS_new 是特权级更高的栈，这说明需要特权级转换，需要切换到新栈。将 旧栈段选择子记作 SS_old，旧栈指针记作 ESP_old。为了返回，我们需要将其 SS_old 和 ESP_old 找个临时的地方保存起来。然后将 SS_new 加载到栈段寄存器，esp_new 加载到栈指针寄存器，这样，便启用了新栈。

![img](https:////upload-images.jianshu.io/upload_images/7304940-ff7bea28a069d71d.png?imageMogr2/auto-orient/strip|imageView2/2/w/430/format/webp)

- 在这一步中要将用户栈中的参数复制到转移后的新栈中，根据调用门描述符中的"参数个数"决定复制几个参数。



![img](https:////upload-images.jianshu.io/upload_images/7304940-5e28ded3ace091f7.png?imageMogr2/auto-orient/strip|imageView2/2/w/430/format/webp)

- 由于调用门描述符中记录的是目标程序所在代码段的选择子及偏移地址。这意味着代码段寄存器 CS 要用选择子重新加载。为了在之后恢复到用户进程，我们同样也需要备份 CS_old 和 EIP_old。



![img](https:////upload-images.jianshu.io/upload_images/7304940-3850e652417fc8bb.png?imageMogr2/auto-orient/strip|imageView2/2/w/430/format/webp)

- 一切就绪，最后只需要把代码段选择子装载到代码段寄存器CS中，把偏移量赋值给EIP。

做了这些，最后处理器就从用户程序转移到内核程序上。下面是 retf 返回时要做的：

- 当处理器执行到 retf 指令，它知道这是远返回，所以需要从 "栈中返回旧栈的地址及返回到低特权级的程序中"，这时候它要进行特权级检查。先检查栈中 CS 选择子，根据其 RPL 位，即未来的 CPL，判断在返回过程中是否要该改变特权级。检查通过，则从栈中弹出 EIP_old -> EIP，CS_old -> CS。
- 如果有参数，则增加栈指针 ESP_new 的值，以跳过栈中参数。此时栈指针 ESP_new 指向 ESP_old。
- 如果在第一步中判断出需要改变特权级，从栈中弹出 ESP_old -> SP ，SS_old -> SS。

--------------------------------------------

原博客地址：https://www.jianshu.com/p/377f473dd0a9