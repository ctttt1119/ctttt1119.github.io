---
layout:     post
title:      操作系统笔记
subtitle:   进（线）切换
date:       2019-11-10
author:     Shawn
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - 操作系统





---

# 操作系统笔记：进（线）切换（未完成）

先用自己话非常通俗的概括一下整个切换的流程。故事开始的时候一个进程（or线程，在这里不加以区分，简单的认为二者的区别只是在是否产生内存映射表的切换，其他方面相同）A正在愉快的运行着，CPU通过取指执行的方式一点点的去执行它的代码，突然遇到一个中断（系统调用、外部中断、异常），然后就要进入到A进程的内核态去执行相应的中断服务例程，在这期间突然不小心发生一个意外，程序的执行由于缺乏某中资源而不得不中止，**而调用了schedule()函数，即产生了进程的切换**。而这块知识的重点并非是schedule()函数如何去选择下一个要被执行的进程，我们跳过这个黑箱，假设现在已经取得下一个进程的PCB和PID，那么剩下的重点就落在了switch_to()这个函数的身上。在切换到了新的进程B的内核栈之后，再利用B的内核栈中保存的用户栈的信息跳转到用户态去执行程序，从而完成了进程的切换。

　　课程介绍了两种切换（switch_to）的方法，概括的说一种是基于TSS的切换，一种是基于内核栈的切换。

------

（一）基于TSS的进（线）程切换

　　首先介绍TSS的概念，Task State Segment，即任务状态段。它记录了cpu执行某个线程的上下文，就是比如这个线程开始执行了5秒钟后cpu中各个寄存器的内容，概括的说是记录从cpu来看整个进程执行到了一个什么样的地步，可以形象的理解为TSS就是个相机，将cpu某一时刻的状态给“咔嚓”地拍了下来。然后由于TSS的本质是一个**段**，所以关于他的寻找遵从保护模式下的段机制，由cpu中的tr寄存器记录当前进程tss所在的位置，然后统一去GDT里面找。有一个任务寄存器（Task Register，简称TR）指向当前进程对应的TSS结构体，所谓的TSS切换就将CPU中几乎所有的寄存器都复制到TR指向的那个TSS结构体中保存起来，同时找到一个目标TSS，即要切换到的下一个进程对应的TSS，将其中存放的寄存器映像“扣在”CPU上，就完成了执行现场的切换，如下图所示。

![image.png](https://i.loli.net/2019/11/10/uJeVb396FYrRilA.png)

Intel架构不仅提供了TSS来实现任务切换，而且只要一条指令就能完成这样的切换，即图中的ljmp指令。具体的工作过程是： 
（1）首先用TR中存取的段选择符在GDT表中找到当前TSS的内存位置，由于TSS是一个段，所以需要用段表中的一个描述符来表示这个段，和在系统启动时论述的内核代码段是一样的，那个段用GDT中的某个表项来描述，还记得是哪项吗？是8对应的第1项。此处的TSS也是用GDT中的某个表项描述，而TR寄存器是用来表示这个段用GDT表中的哪一项来描述，所以TR和CS、DS等寄存器的功能是完全类似的。 
（2）找到了当前的TSS段（就是一段内存区域）以后，将CPU中的寄存器映像存放到这段内存区域中，即拍了一个快照。 
（3）存放了当前进程的执行现场以后，接下来要找到目标进程的现场，并将其扣在CPU上，找目标TSS段的方法也是一样的，因为找段都要从一个描述符表中找，描述TSS的描述符放在GDT表中，所以找目标TSS段也要靠GDT表，当然只要给出目标TSS段对应的描述符在GDT表中存放的位置——段选择子就可以了，仔细想想系统启动时那条著名的jmpi 0, 8指令，这个段选择子就放在ljmp的参数中，实际上就jmpi 0, 8中的8。 
（4）一旦将目标TSS中的全部寄存器映像扣在CPU上，就相当于切换到了目标进程的执行现场了，因为那里有目标进程停下时的CS:EIP，所以此时就开始从目标进程停下时的那个CS:EIP处开始执行，现在目标进程就变成了当前进程，所以TR需要修改为目标TSS段在GDT表中的段描述符所在的位置，因为TR总是指向当前TSS段的段描述符所在的位置。 
上面给出的这些工作都是一句长跳转指令“ljmp 段选择子:段内偏移”，在段选择子指向的段描述符是TSS段时CPU解释执行的结果，所以基于TSS进行进程/线程切换的switch_to本质上就是一句ljmp指令：

GDT表的结构如下图所示，所以第一个TSS表项，即0号进程的TSS表项在第4个位置上，4<<3，即48，相当于TSS在GDT表中开始的位置（以字节为单位），TSS（n）找到的是进程n的TSS位置，所以还要再加上n<<4，即n16，因为每个进程对应有1个TSS和1个LDT，每个描述符的长度都是8个字节，所以是乘以16，其中LDT的作用就是上面论述的那个映射表，关于这个表的详细论述要等到内存管理一章。TSS（n）=n16+48，得到就是进程n（切换到的目标进程）的TSS选择子，将这个值放到dx寄存器中，并且又放置到结构体tmp中32位长整数b的前16位，现在64位tmp中的内容是前32位为空，这个32位数字是段内偏移，就是jmpi 0, 8中的0；接下来的16位是n16+48，这个数字是段选择子，就是jmpi 0, 8中的8，再接下来的16位也为空。所以swith_to的核心实际上就是“ljmp 空, n16+48”，现在和前面给出的基于TSS的进程切换联系在一起了。

![image.png](https://i.loli.net/2019/11/10/jTFQsWuZ4SIk1U8.png)

　　而基于TSS的进程切换要耗费约200个时钟周期，时间较长， 因此又有了基于内核栈的进程切换。

------

（二）基于内核栈的进（线）程切换

　　首先是schedule()函数里传给switch_to()参数的变动

```c
 if ((*p)->state == TASK\_RUNNING \&\& (*p)->counter > c) c = (*p)->counter, next = i, pnext = *p;

 .......

switch_to(pnext, LDT(next));
```

　　不难看出ebp+8也就是pnext参数

```c
switch_to:

     pushl %ebp

     movl %esp,%ebp

     pushl %ecx

     pushl %ebx

     pushl %eax

     movl 8(%ebp),%ebx

     cmpl %ebx,current

     je 1f

     切换PCB

     TSS中的内核栈指针的重写

     切换内核栈

     切换LDT

     movl $0x17,%ecx

     mov %cx,%fs

     cmpl %eax,last_task_used_math //和后面的clts配合来处理协处理器，由于和主题关系不大，此处不做论述

    jne 1f

    clts

 1:    popl %eax

    popl %ebx

    popl %ecx

    popl %ebp

    ret
```

　　**五个步骤：PCB的切换->TSS内核栈指针的重写->内核栈的切换->LDT的切换->PC指针的切换**

　　（1）PCB指针的切换

```c
movl %ebx,%eax   

xchgl %eax,current
```

　　其中ebx中存的是switch_to的第一个参数，即下一个进程的PCB指针，然后和当前指针的值进行交换，从这里我们能看出——所谓的PCB切换实质就是让current指针存入被切换来进程的PCB指针。

　　（2）TSS内核指针的改写

```c
 movl tss,%ecx

addl $4096,%ebx

 movl %ebx,ESP0(%ecx)
```

　　之前提过ebx存放的是新进程PCB指针的地址，之所以要给他加上4096即4K空间是指向了新进程的内存栈指针，由于每个进程的内核栈是由tss中的ss0和esp0共同标记的，所以每次进入内核栈时，任务的内核栈总是空的，而它初始的地址就是PCB首地址+4096。

　　（3）内核栈的切换

　　这步要做的也很简单，就是将cpu中的esp寄存器的内容置成新进程的内核栈首地址即可。

　　（4）LDT的切换

　　指令movl 12(%ebp),%ecx负责取出对应LDT(next)的那个参数，指令lldt %cx负责修改LDTR寄存器，一旦完成了修改，下一个进程在执行用户态程序时使用的映射表就是自己的LDT表了，地址空间实现了分离。

　　（5）PC指针的切换

　　最后一个切换是关于PC的切换，和前面论述的一致，依靠的就是switch_to的最后一句指令ret，虽然简单，但背后发生的事却很多：schedule()函数的最后调用了这个switch_to函数，所以这句指令ret就返回到下一个进程（目标进程）的schedule()函数的末尾，遇到的是}，继续ret回到调用的schedule()地方，是在中断处理中调用的，所以回到了中断处理中，就到了中断返回的地址，再调用iret就到了目标进程的用户态程序去执行，和书中论述的内核态线程切换的五段论是完全一致的。