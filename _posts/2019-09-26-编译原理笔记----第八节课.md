---
layout:     post
title:      编译原理笔记
subtitle:   语法分析（一）
date:       2019-09-26
author:     Shawn
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - 编译原理







---

# 编译原理笔记：语法分析（一）

## 写在前面

**这里想先补充一下为什么左递归会造成死循环而右递归不会，以下解释来自一位带哥：**

比如现在有文法：

```c
A ::= Aa| b
```

我们要自顶向下地推导出符号串'baa'。

在这里有一个默认的条件是，我们从左到右扫描符号串（因为这样很容易编程实现），即如果没有'b'出现，我们就不断地进行推导。

那么实现出来的，不带任何处理措施程序可能是这样的：

```c
A ::= Aa | b
```

```c
const char* target = "xxy";
int index = 0;
int end = 3;
 
bool X() {
    int index_bak = index;
    if (target[index] == 'x') {
        ++index;
       if (X()) {
          return true;
        }
    }
    index = index_bak; 
    if (target[index] == 'y') {
        ++index;
        return true;
    }
    return false;
}
 
int main() {
    assert(X() && index == end);
}
```

可以看到，上面的A()一开始就马上调用下一个A()，这个递归永远不会停止。但是很显然，现在如果我们调换一下A'a'和'b'的匹配优先级，这个问题就能解决了。

事实上如果对于非终结符U，只存在形如 U->U...的规则，不存在任何U->a...这样的规则，那么一旦推出了U，推导过程就永远也不可能停止了，也不存在理论上的消除这种递归的方法。（课本P40有提到这个例子，我相信老师也提到过，这种规则是“多余规则”，一个实用的文法不应该出现这种规则）因此对于不含有害规则和多余规则的实用文法，总有一个实现层面的解决手段，让我们避免这样的死递归

而如果是使用下列右递归文法推导xxy：

```c
`X ::= ``'x'``X | ``'y'`
```

```c
const char* target = "xxy";
int index = 0;
int end = 3;
 
bool X() {
    int index_bak = index;
    if (target[index] == 'x') {
        ++index;
       if (X()) {
          return true;
        }
    }
    index = index_bak; 
    if (target[index] == 'y') {
        ++index;
        return true;
    }
    return false;
}
 
int main() {
    assert(X() && index == end);
}
```

显然，这种右递归文法在面对从左向右的输入扫描时，不会产生任何形式的无限递归，因为输入串的下标总在往后移动，总有一刻会因为失败而回退，或是因为匹配到串尾而结束。

## 一、语法分析概述

- 功能：根据文法规则，从源程序单词符号串中识别出语法成分，并进行语法检查。
- 基本任务：识别符号串S是否为某语法成分。
- 两大类分析方法：自顶向下分析，自底向上分析

## 二、自顶向下分析

- 自顶向下分析为什么不能处理左递归文法？

  如果我们在匹配输入串过程中，假定正好轮到要用非终
  结符U直接匹配输入串，即要用U的右部符号串U¨¨去匹配， 为了用U¨¨去匹配，又得用U去匹配，这样无限地循环下 去，过程将无法终止。如果文法具有间接左递归，则也将发生上述问题，只 不过兜的圈子更大。要实行自顶向下分析，必须要消除文法的左递归。

- **消除直接左递归**

  1. **方法一：使用扩充的BNF改写文法**
  
     例：(1) E∷= E + T | T                  =>                    E∷= T { + T } 
  
     ​	   (2) T∷= T * F | T / F | F         =>                    T∷= F { * F | / F }
     a. 改写以后的文法消除了左递归。 
  
     b. 可以证明，改写前后的文法是等价的，表现在 L(G改前) = L(G改后)
  
     **规则一：提左公因子**
  
     若：U∷= x y | x w |….| x z 
  
     则可改写为：U∷= x ( y | w |….| z ) 
  
     其中再若：y = y1 y2, w = y1 w2 
  
     则 U∷= x ( y1 ( y2 | w2 ) |….| z )
     若有规则：U∷= x | x y 
  
     则可以改写为：U∷= x ( y |ε) 
  
     注意：不应写成U∷= x (ε| y)
     总把ε安置成最后的选择！
  
     **规则二**
  
     若有文法规则：U∷= x | y |…| z | U v
     其特点是：具有一个直接左递归的右部并位于最后，这表明该语法类U是由 x 或y…或 z打头，其后跟随零个或多个 v 组成。
     U => Uv => Uvv => Uvvv =>…… ∴可以改写为U∷= ( x | y |…| z ) { v }
  
  2. **方法二：将左递归规则改为右递归规则**
  
     若：P∷= P α | β 
  
     则可改写为：P ∷= β P’
  
     ​					  P’ ∷= α P’ | ε

- 注意观察间接左递归，间接左递归同样需要去消除左递归

## 三、回溯问题

- 什么是回溯：分析工作要部分地或全部地退回去重做叫回溯。

- 造成回溯的条件：文法中，对于某个非终结符号的规则其右部有多个选择，并根据所面临的输入符号不能准确地确定所要的产生式，就可能出现回溯。

- 回溯带来的问题：效率严重低下，只有在理论上的意义而无实际意义。

- 怎样避免回溯：[定义] 设文法G（不具左递归性），U ∈Vn 

  U::= α 1 | α 2 | α 3

  FIRST(α i ) = {a | α i => a…, a ∈Vt }
  为避免回溯，对文法的要求是: FIRST(αi ) ∩ FIRST(αj ) = φ (i ≠ j)

  **即只要当前文法满足以上要求时，改语法就能避免回溯。**

- **消除回溯的途径**

  1. 改写文法

     ![](https://raw.githubusercontent.com/ctttt1119/ctttt1119.github.io/master/img/bianyi-8-pic1.png)

  2. 超前扫描

     当文法不满足避免回溯的条件时，即各选择的首符号相交时，可以采用超前扫描的方法，即向前侦察各输入符号串的第二个、第三个符号来确定要选择的目标。
     这种方法是通过向前多看几个符号来确定所选择的目标，从本质上来讲也有回溯的味道，因此比第一种方法费时，但是读的仅仅是向前侦察情况，不作任 何语义处理工作。

     其实就是说，试探性地往后读几个，不全部读完，如果是，就可以确定这个目标，如果不是，就换下一个目标。

     例：

     ![](https://raw.githubusercontent.com/ctttt1119/ctttt1119.github.io/master/img/bianyi-8-pic2.png)

- 如果要在不采取超前扫描的前提条件下实现不带回溯的自顶向下分析，对文法需要满足两个条件：

  1、文法是非左递归的；
  2、对文法的任一非终结符，若其规则右部有多个选择时， 各选择所推出的终结符号串的首符号集合要两两不相交。

  （即改写文法后的状态）